import os
import time
import re
import unicodedata
import traceback
import uuid
from concurrent.futures import ThreadPoolExecutor
from typing import Iterable, List, Sequence, Tuple

import gradio as gr
import numpy as np
import soundfile as sf

import yaml
from scipy import signal
import math

from app import synthesize, prompts_list
try:
    from transformers import AutoTokenizer
except Exception:
    AutoTokenizer = None

from datetime import datetime

# Base output directory. Final OUTPUT_DIR will include a timestamped subfolder
OUTPUT_DIR_BASE = "output_audio"

# Create a session-specific output folder: output_audio/YYYYMMDD_HHMMSS
def make_session_output_dir(base: str = OUTPUT_DIR_BASE) -> str:
    ts = datetime.now().strftime("%Y%m%d_%H%M%S")
    out = os.path.join(base, ts)
    try:
        os.makedirs(out, exist_ok=True)
    except Exception:
        # Fallback to base if creation fails
        out = base
        os.makedirs(out, exist_ok=True)
    return out

# Compute OUTPUT_DIR at import/run time so all writers use the same folder
OUTPUT_DIR = make_session_output_dir()
SPEAKER_MAX = 30
PROGRESS_POLL_INTERVAL = 1.0

# --- –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º ---
# –ë–∞–∑–æ–≤–∞ —à–≤–∏–¥–∫—ñ—Å—Ç—å –º–æ–≤–ª–µ–Ω–Ω—è –∑ –∫–æ–¥–æ–≤–æ—ó –±–∞–∑–∏. –Ø–∫—â–æ —É –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó sfx.yaml –ø—Ä–∏—Å—É—Ç–Ω—ñ–π
# –∫–ª—é—á `default_speed`, –≤—ñ–Ω –º–∞—î –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç.
DEFAULT_SPEED_CODE = 0.88

def _load_sfx_config(path: str = "sfx.yaml") -> dict:
    """
    Load SFX configuration from YAML. If the file does not exist or is invalid,
    return a minimal default configuration.
    """
    cfg = {"normalize_dbfs": -16, "sounds": {}}
    try:
        if os.path.exists(path):
            with open(path, "r", encoding="utf-8") as f:
                data = yaml.safe_load(f)
                if isinstance(data, dict):
                    cfg.update(data)
    except Exception:
        # Fall back to default minimal config
        pass
    return cfg


def get_sfx_config(path: str = "sfx.yaml") -> dict:
    """
    Read and return SFX configuration from YAML on demand.

    Unlike _load_sfx_config which may be used once at startup, this helper
    always (re)reads the YAML file so updates to sfx.yaml are picked up
    without restarting the application.
    Returns a dict with at least keys: 'normalize_dbfs' and 'sounds'.
    """
    out = {"normalize_dbfs": -16, "sounds": {}}
    try:
        if os.path.exists(path):
            with open(path, "r", encoding="utf-8") as f:
                data = yaml.safe_load(f)
                if isinstance(data, dict):
                    out.update(data)
    except Exception as e:
        print(f"Warning: could not read SFX config '{path}': {e}")
    return out


def get_sfx_config(path: str = "sfx.yaml") -> dict:
    """
    Read and return SFX configuration from YAML on demand.

    Unlike _load_sfx_config which may be used once at startup, this helper
    always (re)reads the YAML file so updates to sfx.yaml are picked up
    without restarting the application.
    Returns a dict with at least keys: 'normalize_dbfs' and 'sounds'.
    """
    out = {"normalize_dbfs": -16, "sounds": {}}
    try:
        if os.path.exists(path):
            with open(path, "r", encoding="utf-8") as f:
                data = yaml.safe_load(f)
                if isinstance(data, dict):
                    out.update(data)
            # store directory for downstream file resolution
            cfg_dir = os.path.dirname(os.path.abspath(path))
            if cfg_dir:
                out.setdefault("_cfg_dir", cfg_dir)
    except Exception as e:
        print(f"Warning: could not read SFX config '{path}': {e}")
    return out

# Global SFX configuration loaded once
SFX_CONFIG = _load_sfx_config()
DEFAULT_SPEED = float(SFX_CONFIG.get("default_speed", DEFAULT_SPEED_CODE))

class NoProgress:
    """–ú—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–π –æ–±'—î–∫—Ç-–∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å—É progress."""

    def tqdm(self, iterable: Iterable):
        return iterable

def format_hms(seconds):
    h = seconds // 3600
    m = (seconds % 3600) // 60
    s = seconds % 60
    return f"{h:02}:{m:02}:{s:02}"

# ---------- –ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è (–ù–ï —á—ñ–ø–∞—î '+') ----------
def normalize_text(s: str) -> str:
    if not isinstance(s, str):
        return s
    s = unicodedata.normalize("NFKC", s).replace("\ufeff", "")
    # —É–Ω—ñ—Ñ—ñ–∫–∞—Ü—ñ—è –∞–ø–æ—Å—Ç—Ä–æ—Ñ—ñ–≤ —ñ —Ç–∏—Ä–µ
    s = (s.replace("‚Äô","'").replace(" º","'").replace(" ª","'").replace(" π","'")
           .replace("‚Äî","-").replace("‚Äì","-").replace("‚àí","-"))
    # –ø—Ä–∏–±—Ä–∞—Ç–∏ –Ω–µ–≤–∏–¥–∏–º—ñ –∫–µ—Ä—ñ–≤–Ω—ñ (Cf/Cc), –∑–±–µ—Ä–µ–≥—Ç–∏ \n \r \t —ñ '+'
    out = []
    for ch in s:
        if ch == '+':
            out.append(ch); continue
        cat = unicodedata.category(ch)
        if cat in ("Cf","Cc") and ch not in ("\n","\r","\t"):
            continue
        out.append(ch)
    s = "".join(out)
    # NBSP -> –ø—Ä–æ–±—ñ–ª, –ø—ñ–¥—á–∏—Å—Ç–∏—Ç–∏ –ø—Ä–æ–±—ñ–ª–∏ –Ω–∞–≤–∫–æ–ª–æ –ø–µ—Ä–µ–Ω–æ—Å—ñ–≤
    s = s.replace("\u00A0", " ")
    s = re.sub(r"\s*\n\s*", "\n", s)
    return s

# ---------- –¢–æ–∫–µ–Ω–æ-–±–µ–∑–ø–µ—á–Ω–∏–π —Å–ø–ª—ñ—Ç –¥–ª—è PL-BERT (–ª—ñ–º—ñ—Ç 512) ----------
# –î–æ–¥–∞—Ç–∫–æ–≤—ñ –ø–æ—Ä–æ–≥–∏ –±–µ–∑–ø–µ–∫–∏
CHAR_CAP = 1200        # –∂–æ—Ä—Å—Ç–∫–∞ —Å—Ç–µ–ª—è –ø–æ —Å–∏–º–≤–æ–ª–∞—Ö –¥–ª—è –æ–¥–Ω–æ–≥–æ —à–º–∞—Ç–∫–∞
HARD_MAX_TOKENS = 280  # —Ü—ñ–ª—å–æ–≤–∏–π –±—é–¥–∂–µ—Ç —Ç–æ–∫–µ–Ω—ñ–≤ –Ω–∞ —à–º–∞—Ç–æ–∫ (—ñ–∑ –∑–∞–ø–∞—Å–æ–º)
PLBERT_MAX = 512
PLBERT_SAFE = 480       # —â–µ –æ–¥–∏–Ω –∑–∞–ø–∞—Å –±–µ–∑–ø–µ–∫–∏ –ø–µ—Ä–µ–¥ 512
_tok = None
if AutoTokenizer is not None:
    try:
        _tok = AutoTokenizer.from_pretrained("albert-base-v2")
    except Exception:
        _tok = None

def _tok_len(t: str) -> int:
    if _tok is None:
        # –°–£–ü–ï–†-–∫–æ–Ω—Å–µ—Ä–≤–∞—Ç–∏–≤–Ω–∏–π fallback: 1 —Å–∏–º–≤–æ–ª ~ 1 —Ç–æ–∫–µ–Ω + –Ω–µ–≤–µ–ª–∏–∫–∏–π –∑–∞–ø–∞—Å.
        # –¶–µ –Ω–µ –¥–∞—Å—Ç—å –Ω–µ–¥–æ–æ—Ü—ñ–Ω–∏—Ç–∏ —ñ "–ø—Ä–æ–ø—Ö–Ω—É—Ç–∏" >512 —É –º–æ–¥–µ–ª—å.
        return len(t) + 32
    return len(_tok.encode(t, add_special_tokens=True))

def _split_sentence_safe(sent: str, max_tokens: int) -> list[str]:
    """–î—ñ–ª–∏—Ç—å –Ω–∞–¥–¥–æ–≤–≥–µ —Ä–µ—á–µ–Ω–Ω—è –ø–æ —Å–ª–æ–≤–∞—Ö, –Ω–µ —á—ñ–ø–∞—é—á–∏ '+'."""
    parts, buf = [], []
    for tok in re.findall(r"\S+\s*|\s+", sent):
        buf.append(tok)
        if _tok_len("".join(buf)) > max_tokens:
            if len(buf) == 1:
                chunk = tok
                while _tok_len(chunk) > max_tokens:
                    cut = max(64, int(len(chunk) * 0.7))
                    parts.append(chunk[:cut])
                    chunk = chunk[cut:]
                buf = [chunk]
            else:
                last = buf.pop()
                parts.append("".join(buf).strip())
                buf = [last]
    if buf:
        parts.append("".join(buf).strip())
    out = [p for p in parts if p]
    # –¥–æ–¥–∞—Ç–∫–æ–≤–∞ —Å—Ç—Ä–∞—Ö–æ–≤–∫–∞: —Ä—ñ–∂–µ–º–æ –¥—É–∂–µ –¥–æ–≤–≥—ñ —à–º–∞—Ç–∫–∏ –ø–æ –∫–æ–º–∞—Ö/–∫—Ä–∞–ø–∫–∞—Ö —ñ–∑ –≤—ñ–¥—Å—Ç—É–ø–æ–º
    safe = []
    for chunk in out:
        if len(chunk) <= CHAR_CAP and _tok_len(chunk) <= max_tokens:
            safe.append(chunk); continue
        frag = chunk
        # –ø—Ä–æ–±—É—î–º–æ —Ä—ñ–∑–∞—Ç–∏ –ø–æ –∫–æ–º–∞—Ö/–∫—Ä–∞–ø–∫–∞—Ö
        while len(frag) > 0 and (_tok_len(frag) > max_tokens or len(frag) > CHAR_CAP):
            m = re.search(r'(.{200,}?[,;:])\s+', frag, flags=re.DOTALL)
            cut = m.end() if m else min(len(frag), max(300, len(frag)//2))
            safe.append(frag[:cut].strip())
            frag = frag[cut:].lstrip()
        if frag:
            safe.append(frag)
    return safe

def split_to_parts(text: str, max_tokens: int = HARD_MAX_TOKENS) -> list[str]:
    """
    –†–æ–∑–±–∏–≤–∞—î —Ç–∞–∫, —â–æ–± –∫–æ–∂–µ–Ω —à–º–∞—Ç–æ–∫ –±—É–≤ ‚â§~280 —Ç–æ–∫–µ–Ω—ñ–≤ —ñ ‚â§1200 —Å–∏–º–≤–æ–ª—ñ–≤.
    –ü–æ–≤–∞–∂–∞—î –∞–±–∑–∞—Ü–∏ –π —Ä–µ—á–µ–Ω–Ω—è. '+' –∑–±–µ—Ä—ñ–≥–∞—î—Ç—å—Å—è.
    """
    text = normalize_text(text)
    chunks = []
    for para in re.split(r"\n{2,}", text.strip()):
        para = para.strip()
        if not para:
            continue
        # —Ä–æ–∑–±–∏–≤–∫–∞ –Ω–∞ —Ä–µ—á–µ–Ω–Ω—è; —è–∫—â–æ –Ω–µ–º–∞—î –∫—Ä–∞–ø–æ–∫ ‚Äî –æ—Ç—Ä–∏–º–∞—î–º–æ 1 –¥–æ–≤–≥–µ —Ä–µ—á–µ–Ω–Ω—è
        sents = re.split(r"(?<=[\.\!\?‚Ä¶])\s+", para)
        buf = []
        for s in sents:
            cand = (" ".join(buf + [s])).strip() if buf else s.strip()
            if not cand:
                continue
            if _tok_len(cand) <= max_tokens and len(cand) <= CHAR_CAP:
                buf.append(s)
                continue
            # —è–∫—â–æ —Å–∞–º–µ —Ä–µ—á–µ–Ω–Ω—è –¥–æ–≤—à–µ –±—é–¥–∂–µ—Ç—É ‚Äî –¥—Ä–æ–±–∏–º–æ
            if _tok_len(s) > max_tokens or len(s) > CHAR_CAP:
                if buf:
                    chunks.append(" ".join(buf).strip()); buf = []
                chunks.extend(_split_sentence_safe(s, max_tokens))
            else:
                if buf:
                    chunks.append(" ".join(buf).strip())
                buf = [s]
        if buf:
            chunks.append(" ".join(buf).strip())
    # —Ñ—ñ–Ω–∞–ª—å–Ω–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∫–æ–∂–Ω–æ–≥–æ —à–º–∞—Ç–∫–∞
    safe_final = []
    for c in chunks:
        if _tok_len(c) <= max_tokens and len(c) <= CHAR_CAP:
            safe_final.append(c)
        else:
            safe_final.extend(_split_sentence_safe(c, max_tokens))
    return [c for c in safe_final if c]

def parse_dialog_tags(text):
    text = normalize_text(text)
    lines = text.splitlines()
    current_tag = None
    parsed = []
    tag_re = re.compile(r'^#g([1-9]|[12][0-9]|30)\s*:\s*(.*)$', re.I)

    for ln in lines:
        ln = ln.rstrip()
        if not ln:
            continue
        m = tag_re.match(ln)
        if m:
            current_tag = int(m.group(1))
            tail = m.group(2).strip()
            if tail:
                for p in split_to_parts(tail):
                    parsed.append((current_tag, p))
            continue
        sp_idx = current_tag if current_tag is not None else 1
        for p in split_to_parts(ln):
            parsed.append((sp_idx, p))
    return parsed

def parse_script_events(text: str, voices_flat: List[str]) -> List[dict]:
    """
    –ü–∞—Ä—Å–µ—Ä —Å—Ü–µ–Ω–∞—Ä—ñ—é –¥–ª—è Multi Dialog. –ü–µ—Ä–µ—Ç–≤–æ—Ä—é—î —Ç–µ–∫—Å—Ç —É —Å–ø–∏—Å–æ–∫ –ø–æ–¥—ñ–π.

    –î–æ–∑–≤–æ–ª—è—î —Ä—è–¥–∫–∏ –≤–∏–¥—É:
      #gN[_slow|_fast|_slowNN|_fastNN] <—Ç–µ–∫—Å—Ç>  --> –ø–æ–¥—ñ—è voice
      #<sfx_id>                                 --> –ø–æ–¥—ñ—è sfx

    –ü–æ—Ä–æ–∂–Ω—ñ —Ä—è–¥–∫–∏ —Ç–∞ –∫–æ–º–µ–Ω—Ç–∞—Ä—ñ (—Ä—è–¥–∫–∏, —â–æ –ø–æ—á–∏–Ω–∞—é—Ç—å—Å—è –∑ '#' –±–µ–∑ gN –∞–±–æ sfx) —ñ–≥–Ω–æ—Ä—É—é—Ç—å—Å—è.

    –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤–Ω–∏–∫—ñ–≤ —ñ–∑ –ø–æ–ª—è–º–∏:
      {"type": "voice", "g": int, "suffix": str, "text": str}
      {"type": "sfx", "id": str, "params": {}}

    –í–∞–ª—ñ–¥–æ–≤–∞–Ω–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è: –ø–µ—Ä–µ–≤—ñ—Ä—è—î—Ç—å—Å—è —ñ—Å–Ω—É–≤–∞–Ω–Ω—è –≥–æ–ª–æ—Å—ñ–≤ –¥–ª—è gN —Ç–∞ –Ω–∞—è–≤–Ω—ñ—Å—Ç—å SFX —É –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó.
    """
    events: List[dict] = []
    if not isinstance(text, str):
        return events
    lines = normalize_text(text).splitlines()
    # pattern for voice events
    # –î–æ–∑–≤–æ–ª–∏—Ç–∏ —Å—É—Ñ—ñ–∫—Å–∏ slow/fast –∑ 1‚Äì3 —Ü–∏—Ñ—Ä–∞–º–∏ (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥ slow95, fast110)
    # –ü—ñ–¥—Ç—Ä–∏–º–∫–∞ —Ñ–æ—Ä–º–∞—Ç—É –∑ –¥–≤–æ–∫—Ä–∞–ø–∫–æ—é:   #g1: —Ç–µ–∫—Å—Ç   –∞–±–æ  #g2_fast95: —Ç–µ–∫—Å—Ç
    # –¢–æ–±—Ç–æ –ø—ñ—Å–ª—è —Ç–µ–≥–∞ –¥–æ–ø—É—Å–∫–∞—î—Ç—å—Å—è –Ω–µ–æ–±–æ–≤'—è–∑–∫–æ–≤–∞ –¥–≤–æ–∫—Ä–∞–ø–∫–∞ —Ç–∞/–∞–±–æ –ø—Ä–æ–±—ñ–ª–∏.
    voice_pat = re.compile(r"^#g\s*([1-9]|[12][0-9]|30)(?:_((?:slow|fast)(?:\d{1,3})?))?\s*:??\s+(.*)$", re.IGNORECASE)
    # pattern for sfx events (identifier comprised of word characters)
    sfx_pat = re.compile(r'^#([A-Za-z0-9]+)\s*$', re.IGNORECASE)
    for line_no, raw_ln in enumerate(lines, start=1):
        ln = raw_ln.strip()
        if not ln:
            continue
        m_voice = voice_pat.match(ln)
        if m_voice:
            g_str, suffix, text_body = m_voice.groups()
            g_num = int(g_str)
            suffix = suffix.lower() if suffix else ""
            if not text_body.strip():
                raise RuntimeError(f"–ü–æ—Ä–æ–∂–Ω—ñ–π —Ç–µ–∫—Å—Ç –ø—ñ—Å–ª—è —Ç–µ–≥–∞ #g{g_num} –Ω–∞ —Ä—è–¥–∫—É {line_no}")
            # Validate g number range
            if g_num < 1 or g_num > SPEAKER_MAX:
                raise RuntimeError(f"–ù–µ–ø—Ä–∏–ø—É—Å—Ç–∏–º–∏–π –Ω–æ–º–µ—Ä —Å–ø—ñ–∫–µ—Ä–∞: {g_num} –Ω–∞ —Ä—è–¥–∫—É {line_no}")
            # Validate that voice is provided in voices_flat (we only warn later)
            events.append({"type": "voice", "g": g_num, "suffix": suffix, "text": text_body})
            continue
        m_sfx = sfx_pat.match(ln)
        if m_sfx:
            sfx_id = m_sfx.group(1)
            # Validate sfx exists in configuration
            if sfx_id not in SFX_CONFIG.get('sounds', {}):
                raise RuntimeError(f"SFX —ñ–∑ id '{sfx_id}' –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ —É –∫–æ–Ω—Ñ—ñ–≥—É sfx.yaml (—Ä—è–¥–æ–∫ {line_no})")
            events.append({"type": "sfx", "id": sfx_id, "params": {}})
            continue
        # If line starts with '#' and is not a valid tag, treat as comment and skip
        if ln.startswith('#'):
            # comment, ignore
            continue
        # Otherwise line does not have an explicit tag.  Treat it as a voice event for the first speaker (g1)
        # with default speed.  This allows plain text or bullet‚Äëstyle lines to be synthesized
        # without requiring a #gX tag.
        events.append({"type": "voice", "g": 1, "suffix": "", "text": ln})
        continue
    return events

def _compute_speed_effective(g_num: int, suffix: str, speeds_flat: List[float], ignore_speed: bool) -> float:
    """
    –û–±—á–∏—Å–ª—é—î –µ—Ñ–µ–∫—Ç–∏–≤–Ω—É —à–≤–∏–¥–∫—ñ—Å—Ç—å –¥–ª—è voice-–ø–æ–¥—ñ—ó –∑–≥—ñ–¥–Ω–æ –∑ –ø—Ä–∞–≤–∏–ª–∞–º–∏.

    –ü–∞—Ä–∞–º–µ—Ç—Ä–∏:
      g_num       - –ù–æ–º–µ—Ä —Å–ø—ñ–∫–µ—Ä–∞ (1..30)
      suffix      - –¢–µ–≥–æ–≤–∏–π —Å—É—Ñ—ñ–∫—Å ('', 'slow', 'fast', 'slow95', 'fast110', ...)
      speeds_flat - –°–ø–∏—Å–æ–∫ –∑–Ω–∞—á–µ–Ω—å —Å–ª–∞–π–¥–µ—Ä—ñ–≤ —à–≤–∏–¥–∫–æ—Å—Ç—ñ –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ —Å–ø—ñ–∫–µ—Ä–∞
      ignore_speed- –ß–µ–∫–±–æ–∫—Å ¬´–Ü–≥–Ω–æ—Ä—É–≤–∞—Ç–∏ —à–≤–∏–¥–∫—ñ—Å—Ç—å¬ª: –∫–æ–ª–∏ True, —É—Å—ñ voice-—á–∞—Å—Ç–∏–Ω–∏ –º–∞—é—Ç—å DEFAULT_SPEED
    """
    # If user requested to ignore all speeds, use default
    if ignore_speed:
        return DEFAULT_SPEED
    suf = suffix.lower() if suffix else ""
    # Tag-specific speed assignment
    if suf == 'slow':
        return 0.80
    if suf == 'fast':
        return 1.20
    if suf.startswith('slow') and len(suf) > 4:
        # e.g. slow95
        try:
            val = float(suf[4:]) / 100.0
            return val
        except Exception:
            pass
    if suf.startswith('fast') and len(suf) > 4:
        try:
            val = float(suf[4:]) / 100.0
            return val
        except Exception:
            pass
    # If no suffix or parsing fails: use slider value if provided, else default
    if 1 <= g_num <= len(speeds_flat):
        try:
            base_speed = float(speeds_flat[g_num - 1])
        except Exception:
            base_speed = DEFAULT_SPEED
        return base_speed
    return DEFAULT_SPEED

def _load_and_process_sfx(sfx_id: str, target_sr: int) -> Tuple[int, np.ndarray]:
    """
    –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î —Ç–∞ –æ–±—Ä–æ–±–ª—è—î –∞—É–¥—ñ–æ-—Ñ–∞–π–ª SFX:
    - –ß–∏—Ç–∞—î —Ñ–∞–π–ª —ñ–∑ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó
    - –†–µ—Å–µ–º–ø–ª—é—î –¥–æ target_sr
    - –ù–æ—Ä–º–∞–ª—ñ–∑—É—î –¥–æ 'normalize_dbfs' (–∑ –∫–æ–Ω—Ñ—ñ–≥—É) —ñ –∑–∞—Å—Ç–æ—Å–æ–≤—É—î gain_db
    - –î–æ–¥–∞—î –∫–æ—Ä–æ—Ç–∫—ñ fade-in/fade-out (30 –º—Å)

    –ü–æ–≤–µ—Ä—Ç–∞—î (sample_rate, np.array)
    """
    # Read current SFX config on demand so changes in sfx.yaml are picked up
    cfg_all = get_sfx_config()
    cfg = cfg_all.get('sounds', {}).get(sfx_id)
    if not cfg:
        raise RuntimeError(f"SFX –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è –≤—ñ–¥—Å—É—Ç–Ω—è –¥–ª—è id '{sfx_id}'")
    src_file = cfg.get('file')
    if not src_file:
        raise RuntimeError(f"–§–∞–π–ª –¥–ª—è SFX '{sfx_id}' –Ω–µ –≤–∫–∞–∑–∞–Ω–∏–π —É –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó")
    # –ü–æ—à—É–∫ —Ñ–∞–π–ª—É: —Å–ø—Ä–æ–±—É—î–º–æ –∫—ñ–ª—å–∫–∞ –≤–∞—Ä—ñ–∞–Ω—Ç—ñ–≤
    # 1) —à–ª—è—Ö —è–∫ –≤–∫–∞–∑–∞–Ω–æ —É –∫–æ–Ω—Ñ—ñ–≥—É (–º–æ–∂–µ –±—É—Ç–∏ –∞–±—Å–æ–ª—é—Ç–Ω–∏–π)
    # 2) –≤—ñ–¥–Ω–æ—Å–Ω–æ –ø–æ—Ç–æ—á–Ω–æ—ó —Ä–æ–±–æ—á–æ—ó –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—ó
    # 3) –≤—ñ–¥–Ω–æ—Å–Ω–æ OUTPUT_DIR
    # 4) –≤—ñ–¥–Ω–æ—Å–Ω–æ –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—ó sfx.yaml (—è–∫—â–æ –≤—ñ–¥–æ–º–æ)
    # 5) –ø—ñ–¥–ø–∞–ø–∫–∞ 'sound' –ø–æ—Ä—É—á —ñ–∑ sfx.yaml
    possible_paths = [src_file]
    possible_paths.append(os.path.join(os.getcwd(), src_file))
    possible_paths.append(os.path.join(OUTPUT_DIR, src_file))
    # —è–∫—â–æ –≤ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó –∑–±–µ—Ä–µ–∂–µ–Ω–æ —à–ª—è—Ö –¥–æ –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—ó sfx.yaml, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –π–æ–≥–æ
    cfg_dir = cfg_all.get("_cfg_dir")
    if cfg_dir:
        possible_paths.append(os.path.join(cfg_dir, src_file))
        possible_paths.append(os.path.join(cfg_dir, "sound", src_file))
    # —Ç–∞–∫–æ–∂ –ø—Ä–æ–±—É—î–º–æ –≤—ñ–¥–Ω–æ—Å–Ω–æ –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—ó —Å–∫—Ä–∏–ø—Ç—É
    script_dir = os.path.dirname(os.path.abspath(__file__)) if '__file__' in globals() else None
    if script_dir:
        possible_paths.append(os.path.join(script_dir, src_file))
        possible_paths.append(os.path.join(script_dir, "sound", src_file))
    audio_path = None
    for p in possible_paths:
        if p and os.path.exists(p):
            audio_path = p
            break
    if not audio_path:
        tried = ", ".join([p for p in possible_paths if p])
        raise RuntimeError(f"–§–∞–π–ª SFX '{src_file}' –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ (id: '{sfx_id}'). –ü–µ—Ä–µ–≤—ñ—Ä–µ–Ω—ñ —à–ª—è—Ö–∏: {tried}")
    # –ß–∏—Ç–∞–Ω–Ω—è –∞—É–¥—ñ–æ
    data, sr = sf.read(audio_path)
    # –ü–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è —É float32 —Ç–∞ –º–æ–Ω–æ (—è–∫—â–æ —Å—Ç–µ—Ä–µ–æ)
    data = np.asarray(data, dtype=np.float32)
    if data.ndim > 1:
        data = data.mean(axis=1)
    # –†–µ—Å–µ–º–ø–ª –¥–æ target_sr, —è–∫—â–æ –Ω–µ–æ–±—Ö—ñ–¥–Ω–æ
    if sr != target_sr:
        # –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ resample –∑ scipy.signal
        duration = data.shape[0] / sr
        target_len = int(round(duration * target_sr))
        if target_len <= 0:
            target_len = 1
        data = signal.resample(data, target_len)
        sr = target_sr
    # –ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è –≥—É—á–Ω–æ—Å—Ç—ñ –¥–æ normalize_dbfs (–º–æ–∂–Ω–∞ –≤–∏–º–∫–Ω—É—Ç–∏ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ SFX)
    normalize_dbfs = cfg_all.get('normalize_dbfs')
    # –Ø–∫—â–æ —É –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –µ—Ñ–µ–∫—Ç—É —è–≤–Ω–æ –≤–∫–∞–∑–∞–Ω–æ normalize: false ‚Äî –≤—ñ–¥–∫–ª—é—á–∞—î–º–æ –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—é
    if cfg.get('normalize') is False:
        normalize_dbfs = None
    # –ü–æ—Ç–æ—á–Ω–∏–π RMS —Ç–∞ dBFS
    rms = math.sqrt(np.mean(data ** 2)) if data.size else 0.0
    if rms > 0:
        current_dbfs = 20 * math.log10(rms)
    else:
        current_dbfs = -float('inf')
    total_gain_db = float(cfg.get('gain_db', 0.0))
    if normalize_dbfs is not None and current_dbfs > -float('inf'):
        total_gain_db += (float(normalize_dbfs) - current_dbfs)
    # –ó–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è –ø—ñ–¥—Å–∏–ª–µ–Ω–Ω—è
    gain_factor = 10.0 ** (total_gain_db / 20.0)
    data = data * gain_factor
    # –ó–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è fade-in/fade-out (30 –º—Å)
    fade_ms = 30
    fade_len = int(sr * fade_ms / 1000.0)
    fade_len = max(fade_len, 1)
    # Fade-in
    if data.size >= fade_len:
        ramp_in = np.linspace(0.0, 1.0, fade_len, dtype=data.dtype)
        data[:fade_len] *= ramp_in
        ramp_out = np.linspace(1.0, 0.0, fade_len, dtype=data.dtype)
        data[-fade_len:] *= ramp_out
    return sr, data


def _safe_float(value, default: float = 1.0) -> float:
    try:
        return float(value)
    except (TypeError, ValueError):
        return default


def _read_text_source(text_input: str | None, file_path: str | None) -> str:
    if text_input and text_input.strip():
        return text_input
    if file_path:
        with open(file_path, "r", encoding="utf-8") as f:
            return f.read()
    raise RuntimeError("–ù–µ–º–∞—î —Ç–µ–∫—Å—Ç—É –¥–ª—è –æ–∑–≤—É—á–µ–Ω–Ω—è")


def _should_use_single_voice(voice: str | None) -> bool:
    if not voice:
        return False
    vname_l = voice.lower()
    return ("—Ñ—ñ–ª–∞—Ç" in vname_l) or ("filat" in vname_l)


def _needs_plbert_fallback(error_text: str) -> bool:
    return (
        "must match the existing size (512)" in error_text
        or "expanded size of the tensor" in error_text
    )


def _synthesize_chunk(chunk: str, voice: str | None, speed: float) -> Tuple[int, np.ndarray]:
    """–°–∏–Ω—Ç–µ–∑—É—î –æ–¥–∏–Ω —à–º–∞—Ç–æ–∫ —Ç–µ–∫—Å—Ç—É –∑ —É—Ä–∞—Ö—É–≤–∞–Ω–Ω—è–º —É—Å—ñ—Ö –∑–∞–ø–∞—Å–Ω–∏—Ö —Å—Ç—Ä–∞—Ç–µ–≥—ñ–π."""

    use_single = _should_use_single_voice(voice)

    def run_for_parts(parts: Sequence[str]) -> Tuple[int, np.ndarray]:
        waves: List[np.ndarray] = []
        sr_local: int | None = None
        mode = "single" if use_single else "multi"
        voice_name = None if use_single else (voice or None)
        for part in parts:
            txt = normalize_text(part)
            sr_local, audio = synthesize(mode, txt, speed, voice_name=voice_name, progress=NoProgress())
            waves.append(audio)
        if sr_local is None:
            raise RuntimeError("Synthesis did not return sample rate")
        audio_np = waves[0] if len(waves) == 1 else np.concatenate(waves, axis=0)
        return sr_local, audio_np

    parts: List[str] = [chunk]
    if _tok_len(chunk) > PLBERT_SAFE or len(chunk) > CHAR_CAP:
        parts = split_to_parts(chunk, max_tokens=min(HARD_MAX_TOKENS, PLBERT_SAFE // 2))

    try:
        return run_for_parts(parts)
    except Exception:
        first_err = traceback.format_exc()
        if _needs_plbert_fallback(first_err):
            try:
                fallback_parts = split_to_parts(chunk, max_tokens=PLBERT_SAFE // 3)
                return run_for_parts(fallback_parts)
            except Exception:
                raise RuntimeError(f"Synthesis error:\n{traceback.format_exc()}") from None
        raise RuntimeError(f"Synthesis error:\n{first_err}") from None


def batch_synthesize_dialog(text_input, file_path, speeds_flat, voices_flat, save_option):
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    global_start = time.time()

    text = _read_text_source(text_input, file_path)

    parsed = parse_dialog_tags(text)
    total_parts = max(1, len(parsed))
    times_per_part = []

    voice_map = {i + 1: (voices_flat[i] if i < len(voices_flat) else None) for i in range(SPEAKER_MAX)}
    speed_map = {i + 1: (_safe_float(speeds_flat[i]) if i < len(speeds_flat) else 1.0) for i in range(SPEAKER_MAX)}

    start_time_str = time.strftime('%H:%M:%S', time.localtime(global_start))

    yield (None, gr.update(value=1, maximum=total_parts, interactive=False), "0 —Å–µ–∫", start_time_str, "", "–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫...", "", gr.update(value=0, maximum=total_parts, interactive=False))

    for idx, (tag_num, chunk) in enumerate(parsed, start=1):
        part_start = time.time()
        voice = voice_map.get(tag_num, None)
        spd = speed_map.get(tag_num, 1.0)

        with ThreadPoolExecutor(max_workers=1) as executor:
            future = executor.submit(_synthesize_chunk, chunk, voice, spd)

            while not future.done():
                now = time.time()
                elapsed = int(now - global_start)
                elapsed_str = f"{elapsed} —Å–µ–∫ --- {format_hms(elapsed)}"
                est_finish_str = '–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫...'
                rem_text = '–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫...'
                if times_per_part:
                    avg_time = sum(times_per_part) / len(times_per_part)
                    est_total_time = avg_time * total_parts
                    est_finish_str = time.strftime('%H:%M:%S', time.localtime(global_start + est_total_time))
                    rem_secs = int(global_start + est_total_time - now)
                    rem_min, rem_sec = divmod(max(rem_secs, 0), 60)
                    rem_text = f"–¥–æ –∑–∞–∫—ñ–Ω—á–µ–Ω–Ω—è –∑–∞–ª–∏—à–∏–ª–æ—Å—è {rem_min} —Ö–≤ {rem_sec} —Å–µ–∫"

                yield (None, gr.update(value=idx, maximum=total_parts, interactive=False), elapsed_str, start_time_str, None, est_finish_str, rem_text, gr.update(value=max(idx-1, 0), maximum=total_parts, interactive=False))
                time.sleep(PROGRESS_POLL_INTERVAL)

            sr, audio_np = future.result()
        audio_filename = os.path.join(OUTPUT_DIR, f"part_{idx:03}.wav")
        sf.write(audio_filename, audio_np, sr)

        if save_option == '–ó–±–µ—Ä–µ–≥—Ç–∏ –≤—Å—ñ —á–∞—Å—Ç–∏–Ω–∏ –æ–∑–≤—É—á–µ–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç—É':
            txt_filename = os.path.join(OUTPUT_DIR, f"part_{idx:03}.txt")
            with open(txt_filename, 'w', encoding='utf-8') as txt_file:
                txt_file.write(chunk)

        part_end = time.time()
        times_per_part.append(part_end - part_start)

        end_time_str = time.strftime('%H:%M:%S', time.localtime(part_end))
        elapsed_seconds = int(part_end - global_start)
        elapsed_total = f"{elapsed_seconds} —Å–µ–∫ --- {format_hms(elapsed_seconds)}"

        yield (audio_filename, gr.update(value=idx, maximum=total_parts, interactive=False), elapsed_total, start_time_str, end_time_str, None, "", gr.update(value=idx, maximum=total_parts, interactive=False))

    total_elapsed_secs = int(time.time() - global_start)
    total_formatted = format_hms(total_elapsed_secs)
    print(f"\033[92m–ó–∞—Ç—Ä–∞—á–µ–Ω–æ —á–∞—Å—É: {total_formatted}\033[0m")
    yield (
        None,
        gr.update(value=total_parts, maximum=total_parts, interactive=True),
        f"–ó–∞–≤–µ—Ä—à–µ–Ω–æ –∑–∞ {total_elapsed_secs} —Å–µ–∫",
        start_time_str,
        time.strftime('%H:%M:%S', time.localtime(time.time())),
        None,
        "",
        gr.update(value=total_parts, maximum=total_parts, interactive=False)
    )

# -----------------------------------------------------------------------------
# –ù–æ–≤–∏–π –≤–∞—Ä—ñ–∞–Ω—Ç –ø–∞–∫–µ—Ç–Ω–æ—ó –æ–∑–≤—É—á–∫–∏ Multi Dialog –∑ –ø—ñ–¥—Ç—Ä–∏–º–∫–æ—é –ø–æ–¥—ñ–π (voice/sfx),
# —à–≤–∏–¥–∫—ñ—Å–Ω–∏—Ö —Å—É—Ñ—ñ–∫—Å—ñ–≤ —Ç–∞ SFX. –§—É–Ω–∫—Ü—ñ—è —Å—Ç–≤–æ—Ä—é—î –æ–¥–∏–Ω –ª–æ–≥-—Ñ–∞–π–ª —É –ø–∞–ø—Ü—ñ
# OUTPUT_DIR —ñ –ø–æ–≤–µ—Ä—Ç–∞—î –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –¥–ª—è Gradio UI. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è —É
# _btn_d_handler –∑–∞–º—ñ—Å—Ç—å —Å—Ç–∞—Ä–æ—ó batch_synthesize_dialog.
def batch_synthesize_dialog_events(
    text_input: str | None,
    file_path: str | None,
    speeds_flat: list,
    voices_flat: list,
    save_option,
    ignore_speed: bool = False,
) -> Iterable:
    """
    –û–±—Ä–æ–±–ª—è—î —Å—Ü–µ–Ω–∞—Ä—ñ–π Multi Dialog, –ø—ñ–¥—Ç—Ä–∏–º—É—é—á–∏ SFX —Ç–∞ —Å—É—Ñ—ñ–∫—Å–∏ —à–≤–∏–¥–∫–æ—Å—Ç—ñ.
    –ù–∞ –∫–æ–∂–Ω—É –ø–æ–¥—ñ—é (voice –∞–±–æ sfx) —Å—Ç–≤–æ—Ä—é—î .wav —Ñ–∞–π–ª part_{k:03}.wav —ñ, –∑–∞ –±–∞–∂–∞–Ω–Ω—è,
    –∑–∞–ø–∏—Å—É—î —Ç–µ–∫—Å—Ç part_{k:03}.txt. –£—Å—ñ –ø–æ–¥—ñ—ó –ª–æ–≥—É—é—Ç—å—Å—è —É log_{timestamp}.txt.

    Parameters:
        text_input: –¢–µ–∫—Å—Ç —ñ–∑ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –ø–æ–ª—è (–º–æ–∂–µ –±—É—Ç–∏ None).
        file_path: –®–ª—è—Ö –¥–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Ñ–∞–π–ª—É (–º–æ–∂–µ –±—É—Ç–∏ None).
        speeds_flat: –ó–Ω–∞—á–µ–Ω–Ω—è —Å–ª–∞–π–¥–µ—Ä—ñ–≤ —à–≤–∏–¥–∫–æ—Å—Ç—ñ (—Å–ø–∏—Å–æ–∫ —ñ–∑ 30 –µ–ª–µ–º–µ–Ω—Ç—ñ–≤).
        voices_flat: –ó–Ω–∞—á–µ–Ω–Ω—è dropdown –¥–ª—è –≥–æ–ª–æ—Å—ñ–≤ (—Å–ø–∏—Å–æ–∫ —ñ–∑ 30 –µ–ª–µ–º–µ–Ω—Ç—ñ–≤).
        save_option: –û–ø—Ü—ñ—è –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è —Ç–µ–∫—Å—Ç–æ–≤–∏—Ö —á–∞—Å—Ç–∏–Ω.
        ignore_speed: –Ø–∫—â–æ True, —ñ–≥–Ω–æ—Ä—É–≤–∞—Ç–∏ —Å—É—Ñ—ñ–∫—Å–∏ —Ç–∞ –∑–Ω–∞—á–µ–Ω–Ω—è —Å–ª–∞–π–¥–µ—Ä—ñ–≤ —ñ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ DEFAULT_SPEED.
    Returns:
        –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä, —â–æ yield'–∏—Ç—å –∫–æ—Ä—Ç–µ–∂—ñ –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å—É Gradio.
    """
    # –°—Ç–≤–æ—Ä–∏—Ç–∏ –≤–∏—Ö—ñ–¥–Ω–∏–π –∫–∞—Ç–∞–ª–æ–≥ —ñ –∑–∞—Ñ—ñ–∫—Å—É–≤–∞—Ç–∏ —á–∞—Å —Å—Ç–∞—Ä—Ç—É
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    global_start = time.time()
    # –ü—Ä–æ—á–∏—Ç–∞—Ç–∏ —Ç–µ–∫—Å—Ç –∑ –ø–æ–ª—è –∞–±–æ —Ñ–∞–π–ª—É
    text = _read_text_source(text_input, file_path)
    # –ü—ñ–¥–≥–æ—Ç–æ–≤–∫–∞ —á–∞—Å—É —Å—Ç–∞—Ä—Ç—É –¥–ª—è –∫–æ–Ω—Å–æ–ª—ñ
    start_time_str = time.strftime('%H:%M:%S', time.localtime(global_start))
    print(f'Start: {start_time_str}')
    # –ü–∞—Ä—Å–∏–Ω–≥ —Å—Ü–µ–Ω–∞—Ä—ñ—é —É —Å–ø–∏—Å–æ–∫ –ø–æ–¥—ñ–π
    try:
        events = parse_script_events(text, voices_flat)
    except Exception as e:
        print(f'Error while parsing script: {e}')
        raise
    total_parts = max(1, len(events))
    times_per_part: List[float] = []
    warnings: List[str] = []
    base_sr: int | None = None
    # –°–ª–æ–≤–Ω–∏–∫ –≥–æ–ª–æ—Å—ñ–≤ –ø–æ g-–Ω–æ–º–µ—Ä—É
    voice_map = {i + 1: (voices_flat[i] if i < len(voices_flat) else None) for i in range(SPEAKER_MAX)}
    # –ü–æ—á–∞—Ç–∫–æ–≤–µ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å—É
    yield (
        None,
        gr.update(value=1, maximum=total_parts, interactive=False),
        "0 —Å–µ–∫",
        start_time_str,
        "",
        "–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫...",
        "",
        gr.update(value=0, maximum=total_parts, interactive=False),
    )
    # –û–±—Ä–æ–±–ª—è—î–º–æ –≤—Å—ñ –ø–æ–¥—ñ—ó –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ
    for idx, event in enumerate(events, start=1):
        part_start = time.time()
        # –í–∏–∑–Ω–∞—á–∏—Ç–∏ —Ç–∏–ø –ø–æ–¥—ñ—ó
        if event.get('type') == 'voice':
            g_num = event.get('g')
            suffix = event.get('suffix', '')
            text_body = event.get('text', '')
            voice_name = voice_map.get(g_num, None)
            # –û–±—á–∏—Å–ª–∏—Ç–∏ –µ—Ñ–µ–∫—Ç–∏–≤–Ω—É —à–≤–∏–¥–∫—ñ—Å—Ç—å
            speed_eff = _compute_speed_effective(g_num, suffix, speeds_flat, ignore_speed)
            # –ó–±–µ—Ä–µ–≥—Ç–∏ –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è –ø—Ä–æ –≤–∏—Ö—ñ–¥ –∑–∞ –º–µ–∂—ñ —Å–ª–∞–π–¥–µ—Ä–∞
            if not ignore_speed and (speed_eff < 0.7 or speed_eff > 1.3):
                warnings.append(f'–í–∏—Ö—ñ–¥ –∑–∞ –º–µ–∂—ñ —Å–ª–∞–π–¥–µ—Ä–∞ —à–≤–∏–¥–∫–æ—Å—Ç—ñ –¥–ª—è #g{g_num}: {speed_eff:.2f}')
            # –ü–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è —è–∫—â–æ –≥–æ–ª–æ—Å –Ω–µ –æ–±—Ä–∞–Ω–æ
            if not voice_name:
                warnings.append(f'–ù–µ –≤–∫–∞–∑–∞–Ω–æ –≥–æ–ª–æ—Å –¥–ª—è #g{g_num}, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏–π –≥–æ–ª–æ—Å.')
            call_func = _synthesize_chunk
            call_args = (text_body, voice_name, speed_eff)
            extra_info = {
                "type": "voice",
                "g": g_num,
                "voice_name": voice_name,
                "speed_eff": speed_eff,
                "text_len": len(text_body),
                "text_body": text_body,
            }
        elif event.get('type') == 'sfx':
            sfx_id = event.get('id')
            # –í–∏–∑–Ω–∞—á–∏—Ç–∏ —á–∞—Å—Ç–æ—Ç—É –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü—ñ—ó: –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ –±–∞–∑–æ–≤—É, —è–∫—â–æ –≤–æ–Ω–∞ –≤–∂–µ –≤—ñ–¥–æ–º–∞, —ñ–Ω–∞–∫—à–µ ‚Äì 24000 –∞–±–æ –∑–Ω–∞—á–µ–Ω–Ω—è –∑ –∫–æ–Ω—Ñ—ñ–≥—É
            target_sr = base_sr if base_sr else int(SFX_CONFIG.get('default_sr', 24000))
            call_func = _load_and_process_sfx
            call_args = (sfx_id, target_sr)
            cfg = SFX_CONFIG.get('sounds', {}).get(sfx_id, {})
            extra_info = {
                "type": "sfx",
                "sfx_id": sfx_id,
                "file": cfg.get('file'),
                "gain_db": cfg.get('gain_db', 0.0),
            }
        else:
            warnings.append(f"–ù–µ–≤—ñ–¥–æ–º–∏–π —Ç–∏–ø –ø–æ–¥—ñ—ó: {event}")
            continue
        # –í–∏–∫–æ–Ω–∞—Ç–∏ —Å–∏–Ω—Ç–µ–∑ –∞–±–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —É –æ–∫—Ä–µ–º–æ–º—É –ø–æ—Ç–æ—Ü—ñ, —â–æ–± –º–æ–∂–Ω–∞ –±—É–ª–æ –æ–Ω–æ–≤–ª—é–≤–∞—Ç–∏ –ø—Ä–æ–≥—Ä–µ—Å
        with ThreadPoolExecutor(max_workers=1) as executor:
            future = executor.submit(call_func, *call_args)
            while not future.done():
                now = time.time()
                elapsed = int(now - global_start)
                elapsed_str = f"{elapsed} —Å–µ–∫ --- {format_hms(elapsed)}"
                est_finish_str = '–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫...'
                rem_text = '–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫...'
                if times_per_part:
                    avg_time = sum(times_per_part) / len(times_per_part)
                    est_total_time = avg_time * total_parts
                    est_finish_str = time.strftime('%H:%M:%S', time.localtime(global_start + est_total_time))
                    rem_secs = int(global_start + est_total_time - now)
                    rem_min, rem_sec = divmod(max(rem_secs, 0), 60)
                    rem_text = f"–¥–æ –∑–∞–∫—ñ–Ω—á–µ–Ω–Ω—è –∑–∞–ª–∏—à–∏–ª–æ—Å—è {rem_min} —Ö–≤ {rem_sec} —Å–µ–∫"
                yield (
                    None,
                    gr.update(value=idx, maximum=total_parts, interactive=False),
                    elapsed_str,
                    start_time_str,
                    None,
                    est_finish_str,
                    rem_text,
                    gr.update(value=max(idx - 1, 0), maximum=total_parts, interactive=False),
                )
                time.sleep(PROGRESS_POLL_INTERVAL)
            try:
                sr, audio_np = future.result()
            except Exception as e:
                # –í–∏–≤–µ—Å—Ç–∏ –ø–æ–º–∏–ª–∫—É —É –∫–æ–Ω—Å–æ–ª—å –±–µ–∑ –∑–∞–ø–∏—Å—É —É —Ñ–∞–π–ª
                print(f'Error processing part {idx}: {e}')
                raise
        # –î–ª—è –ø–µ—Ä—à–æ–≥–æ voice –∑–∞–ø–∞–º'—è—Ç–∞—Ç–∏ —á–∞—Å—Ç–æ—Ç—É –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü—ñ—ó
        if extra_info["type"] == "voice" and base_sr is None:
            base_sr = sr
        # –ó–∞–ø–∏—Å–∞—Ç–∏ –∞—É–¥—ñ–æ —Ñ–∞–π–ª
        audio_filename = os.path.join(OUTPUT_DIR, f"part_{idx:03}.wav")
        sf.write(audio_filename, audio_np, sr)
        # –ó–∞ –ø–æ—Ç—Ä–µ–±–∏ ‚Äì –∑–∞–ø–∏—Å–∞—Ç–∏ —Ç–µ–∫—Å—Ç–æ–≤–∏–π —Ñ–∞–π–ª
        if save_option == '–ó–±–µ—Ä–µ–≥—Ç–∏ –≤—Å—ñ —á–∞—Å—Ç–∏–Ω–∏ –æ–∑–≤—É—á–µ–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç—É' and extra_info["type"] == "voice":
            txt_filename = os.path.join(OUTPUT_DIR, f"part_{idx:03}.txt")
            with open(txt_filename, 'w', encoding='utf-8') as txt_file:
                txt_file.write(extra_info["text_body"])
        # –í–∏–≤–µ—Å—Ç–∏ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é —É –∫–æ–Ω—Å–æ–ª—å
        if extra_info["type"] == "voice":
            print(f'Part {idx}: type=voice, g={extra_info["g"]}, voice={extra_info["voice_name"]}, speed={extra_info["speed_eff"]:.2f}, text_len={extra_info["text_len"]}, path={audio_filename}')
        else:
            # –î–ª—è SFX: –¥—Ä—É–∫—É—î–º–æ —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä —ñ —à–ª—è—Ö –¥–æ —Ñ–∞–π–ª—É
            print(f'#{extra_info["sfx_id"]} --- —Ñ–∞–π–ª "{extra_info["file"]}" -- {os.path.basename(audio_filename)}')
        # –û–Ω–æ–≤–∏—Ç–∏ —Ç–∞–π–º—ñ–Ω–≥–∏ —Ç–∞ UI
        part_end = time.time()
        times_per_part.append(part_end - part_start)
        end_time_str = time.strftime('%H:%M:%S', time.localtime(part_end))
        elapsed_seconds = int(part_end - global_start)
        elapsed_total = f"{elapsed_seconds} —Å–µ–∫ --- {format_hms(elapsed_seconds)}"
        yield (
            audio_filename,
            gr.update(value=idx, maximum=total_parts, interactive=False),
            elapsed_total,
            start_time_str,
            end_time_str,
            None,
            "",
            gr.update(value=idx, maximum=total_parts, interactive=False),
        )
    # –ü—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è ‚Äì –∑–∞–ø–∏—Å–∞—Ç–∏ –ø—ñ–¥—Å—É–º–æ–∫
    total_elapsed_secs = int(time.time() - global_start)
    total_formatted = format_hms(total_elapsed_secs)
    finish_time_str = time.strftime('%H:%M:%S', time.localtime(time.time()))
    print(f'Finished: {finish_time_str}, duration: {total_formatted}, parts: {len(events)}')
    if warnings:
        print('Warnings:')
        for w in warnings:
            print(f'  - {w}')
    print(f"\033[92m–ó–∞—Ç—Ä–∞—á–µ–Ω–æ —á–∞—Å—É: {total_formatted}\033[0m")
    yield (
        None,
        gr.update(value=total_parts, maximum=total_parts, interactive=True),
        f"–ó–∞–≤–µ—Ä—à–µ–Ω–æ –∑–∞ {total_elapsed_secs} —Å–µ–∫",
        start_time_str,
        finish_time_str,
        None,
        "",
        gr.update(value=total_parts, maximum=total_parts, interactive=False),
    )
save_choices = ['–ó–±–µ—Ä–µ–≥—Ç–∏ –≤—Å—ñ —á–∞—Å—Ç–∏–Ω–∏ –æ–∑–≤—É—á–µ–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç—É', '–ë–µ–∑ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è']

with gr.Blocks(title="Batch TTS –∑ –ü—Ä–æ–≥—Ä–µ—Å–æ–º") as demo:
    with gr.Tabs():
        with gr.TabItem('Multi Dialog'):
            text_input_d = gr.Textbox(label='üìã –í–≤–µ–¥—ñ—Ç—å —Ç–µ–∫—Å—Ç –∞–±–æ –∑–∞–ª–∏—à—Ç–µ –ø–æ—Ä–æ–∂–Ω—ñ–º —ñ –æ–±–µ—Ä—ñ—Ç—å —Ñ–∞–π–ª', lines=10, placeholder='–í—Å—Ç–∞–≤—Ç–µ —Ç–µ–∫—Å—Ç —Ç—É—Ç...')
            file_input_d = gr.File(label='–ê–±–æ –æ–±–µ—Ä—ñ—Ç—å —Ç–µ–∫—Å—Ç–æ–≤–∏–π —Ñ–∞–π–ª', type='filepath')
            speaker_choices = prompts_list

            # ===== –ö–æ–º–ø–æ–Ω–µ–Ω—Ç–∏ –≥–æ–ª–æ—Å—ñ–≤ —ñ —à–≤–∏–¥–∫–æ—Å—Ç–µ–π (—É –ø–æ—Ä—è–¥–∫—É #g1..#g30) =====
            voice_components: list[gr.Dropdown] = []
            speed_components: list[gr.Slider] = []
            DEFAULT_VISIBLE = 3  # –¥–µ—Ñ–æ–ª—Ç –¥–ª—è –∞–≤—Ç–æ–ø—ñ–¥—Å–≤—ñ—Ç–ª–µ–Ω–Ω—è –ø—ñ—Å–ª—è –≤–≤–µ–¥–µ–Ω–Ω—è

            gr.Markdown("**–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –≥–æ–ª–æ—Å—ñ–≤**")

            # --- –î–æ–ø–æ–º—ñ–∂–Ω–∏–π –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –∫–ª—ñ—Ç–∏–Ω–∫–∏ –¥–ª—è –æ–¥–Ω–æ–≥–æ —Å–ø—ñ–∫–µ—Ä–∞ ---
            def _speaker_cell(i: int):
                # –í–ê–ñ–õ–ò–í–û: —Ä–æ–±–∏–º–æ –µ–ª–µ–º–µ–Ω—Ç–∏ –≤–∏–¥–∏–º–∏–º–∏ –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º, —â–æ–± –∞–∫–æ—Ä–¥–µ–æ–Ω–∏ –Ω–µ –≤–∏–≥–ª—è–¥–∞–ª–∏ –ø–æ—Ä–æ–∂–Ω—ñ–º–∏.
                # –ü–æ–¥–∞–ª—å—à–∞ –ª–æ–≥—ñ–∫–∞ –∞–≤—Ç–æ–ø—Ä–∏—Ö–æ–≤—É–≤–∞–Ω–Ω—è –∫–µ—Ä—É—î—Ç—å—Å—è on_text_changed/on_file_changed.
                dd = gr.Dropdown(
                    label=f'–ì–æ–ª–æ—Å –¥–ª—è #g{i}',
                    choices=speaker_choices,
                    value=speaker_choices[0],
                    visible=True
                )
                sv = gr.Slider(0.7, 1.3, value=0.88, label=f'–®–≤–∏–¥–∫—ñ—Å—Ç—å –¥–ª—è #g{i}', visible=True)
                voice_components.append(dd)
                speed_components.append(sv)

            # ===== –ì–†–£–ü–ê 1: #g1‚Äì#g3 (–∞–∫–æ—Ä–¥–µ–æ–Ω –≤—ñ–¥–∫—Ä–∏—Ç–∏–π) =====
            with gr.Accordion("–°–ø—ñ–∫–µ—Ä–∏ #g1‚Äì#g3", open=True) as acc_1_3:
                with gr.Row():
                    for i in (1, 2, 3):
                        with gr.Column():
                            _speaker_cell(i)

            # ===== –ì–†–£–ü–ê 2: #g4‚Äì#g12 (–∞–∫–æ—Ä–¥–µ–æ–Ω –∑–∞–∫—Ä–∏—Ç–∏–π) =====
            with gr.Accordion("–°–ø—ñ–∫–µ—Ä–∏ #g4‚Äì#g12", open=False) as acc_4_12:
                # –†—è–¥ 1: #g4 #g5 #g6
                with gr.Row():
                    for i in (4, 5, 6):
                        with gr.Column():
                            _speaker_cell(i)
                # –†—è–¥ 2: #g7 #g8 #g9
                with gr.Row():
                    for i in (7, 8, 9):
                        with gr.Column():
                            _speaker_cell(i)
                # –†—è–¥ 3: #g10 #g11 #g12
                with gr.Row():
                    for i in (10, 11, 12):
                        with gr.Column():
                            _speaker_cell(i)

            # ===== –ì–†–£–ü–ê 3: –î–æ–¥–∞—Ç–∫–æ–≤—ñ –≥–æ–ª–æ—Å–∏ (–∞–∫–æ—Ä–¥–µ–æ–Ω –∑–∞–∫—Ä–∏—Ç–∏–π) =====
            with gr.Accordion("–î–æ–¥–∞—Ç–∫–æ–≤—ñ –≥–æ–ª–æ—Å–∏", open=False) as acc_more:
                # --- –ü—ñ–¥–≥—Ä—É–ø–∞: #g13‚Äì#g21 ---
                with gr.Accordion("–°–ø—ñ–∫–µ—Ä–∏ #g13‚Äì#g21", open=False) as acc_13_21:
                    with gr.Row():
                        for i in (13, 14, 15):
                            with gr.Column():
                                _speaker_cell(i)
                    with gr.Row():
                        for i in (16, 17, 18):
                            with gr.Column():
                                _speaker_cell(i)
                    with gr.Row():
                        for i in (19, 20, 21):
                            with gr.Column():
                                _speaker_cell(i)
                # --- –ü—ñ–¥–≥—Ä—É–ø–∞: #g22‚Äì#g30 ---
                with gr.Accordion("–°–ø—ñ–∫–µ—Ä–∏ #g22‚Äì#g30", open=False) as acc_22_30:
                    with gr.Row():
                        for i in (22, 23, 24):
                            with gr.Column():
                                _speaker_cell(i)
                    with gr.Row():
                        for i in (25, 26, 27):
                            with gr.Column():
                                _speaker_cell(i)
                    with gr.Row():
                        for i in (28, 29, 30):
                            with gr.Column():
                                _speaker_cell(i)

                # --- –û–ø—Ü—ñ—ó –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è –ø—ñ–¥ —Å–ø–æ–π–ª–µ—Ä–æ–º —É—Å–µ—Ä–µ–¥–∏–Ω—ñ ¬´–î–æ–¥–∞—Ç–∫–æ–≤—ñ –≥–æ–ª–æ—Å–∏¬ª ---
                with gr.Accordion("–û–ø—Ü—ñ—ó –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è", open=False) as acc_opts:
                    save_option_d = gr.Radio(choices=save_choices, label='–û–ø—Ü—ñ—ó –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è', value=save_choices[1])
                    with gr.Row():
                        # 1) –ó–±–µ—Ä–µ–≥—Ç–∏ —è–∫ —Ñ–∞–π–ª (Download)
                        save_settings_download_btn = gr.DownloadButton("üíæ –ó–±–µ—Ä–µ–≥—Ç–∏ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –º–æ–≤—Ü—ñ–≤")
                        # 2) –ó–±–µ—Ä–µ–≥—Ç–∏ —É –ø–∞–ø–∫—É –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º
                        save_settings_default_btn = gr.Button("üìÅ –ó–±–µ—Ä–µ–≥—Ç–∏ —É –ø–∞–ø–∫—É –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º")
                        # 3) –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∑ —Ñ–∞–π–ª—É
                        load_settings_btn = gr.UploadButton(
                            "üìÇ –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è (.txt)",
                            file_types=[".txt"],
                            file_count="single"
                        )

            # --- –ê–≤—Ç–æ–≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è –∫—ñ–ª—å–∫–æ—Å—Ç—ñ —Å–ø—ñ–∫–µ—Ä—ñ–≤ —ñ–∑ —Ç–µ–∫—Å—Ç—É + –∞–≤—Ç–æ–∫–µ—Ä—É–≤–∞–Ω–Ω—è –≤–∏–¥–∏–º—ñ—Å—Ç—é —Ç–∞ –≤—ñ–¥–∫—Ä–∏—Ç—Ç—è–º –∞–∫–æ—Ä–¥–µ–æ–Ω—ñ–≤ ---
            # –®—É–∫–∞—î–º–æ –Ω–∞–π–±—ñ–ª—å—à–∏–π —Ç–µ–≥ #gN —É —Ç–µ–∫—Å—Ç—ñ. –°—É—Ñ—ñ–∫—Å–∏ (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥ _fast110) –¥–æ–ø—É—Å–∫–∞—é—Ç—å—Å—è.
            _g_tag_re = re.compile(r'#g\s*([1-9]|[12]\d|30)', re.IGNORECASE)

            def _max_g_tag_from_text(s: str | None) -> int:
                if not s:
                    return DEFAULT_VISIBLE
                m = [int(x) for x in _g_tag_re.findall(s)]
                if not m:
                    return DEFAULT_VISIBLE
                return max(1, min(30, max(m)))

            def _visibility_updates(n: int):
                # 30 dropdown + 30 sliders
                updates = []
                for i in range(1, 31):
                    show = (i <= n)
                    updates.append(gr.update(visible=show))  # dropdown
                for i in range(1, 31):
                    show = (i <= n)
                    updates.append(gr.update(visible=show))  # slider
                # –í—ñ–¥–∫—Ä–∏–≤–∞—Ç–∏ –ª–∏—à–µ —Ç—ñ –∞–∫–æ—Ä–¥–µ–æ–Ω–∏, –¥–µ —î –≤–∏–¥–∏–º—ñ –µ–ª–µ–º–µ–Ω—Ç–∏
                acc_updates = [
                    gr.update(open=(n >= 1)),   # acc_1_3
                    gr.update(open=(n >= 4)),   # acc_4_12
                    gr.update(open=(n >= 13)),  # acc_more
                    gr.update(open=(n >= 13)),  # acc_13_21
                    gr.update(open=(n >= 22)),  # acc_22_30
                    gr.update(open=False),      # acc_opts –∑–∞–ª–∏—à–∞—î—Ç—å—Å—è –∑–∞–∫—Ä–∏—Ç–∏–º
                ]
                return updates + acc_updates

            def on_text_changed(txt):
                n = _max_g_tag_from_text(txt)
                return _visibility_updates(n)

            def on_file_changed(path_like):
                p = None
                if isinstance(path_like, str):
                    p = path_like
                elif isinstance(path_like, dict):
                    p = path_like.get("name") or path_like.get("path")
                if not p or not os.path.exists(p):
                    return _visibility_updates(DEFAULT_VISIBLE)
                try:
                    with open(p, "r", encoding="utf-8") as f:
                        txt = f.read()
                except Exception:
                    txt = ""
                n = _max_g_tag_from_text(txt)
                return _visibility_updates(n)

            # –ü–æ–¥—ñ—ó: –ø—ñ–¥–ª–∞—à—Ç–æ–≤—É—î–º–æ –≤–∏–¥–∏–º—ñ—Å—Ç—å —Ç–∞ –≤—ñ–¥–∫—Ä–∏—Ç—Ç—è –∞–∫–æ—Ä–¥–µ–æ–Ω—ñ–≤ –ø—ñ–¥ –º–∞–∫—Å–∏–º—É–º #gN
            text_input_d.change(
                fn=on_text_changed,
                inputs=[text_input_d],
                outputs=(voice_components + speed_components + [acc_1_3, acc_4_12, acc_more, acc_13_21, acc_22_30, acc_opts])
            )
            file_input_d.change(
                fn=on_file_changed,
                inputs=[file_input_d],
                outputs=(voice_components + speed_components + [acc_1_3, acc_4_12, acc_more, acc_13_21, acc_22_30, acc_opts])
            )
            # –ö–Ω–æ–ø–∫–∞ –∑–∞–ø—É—Å–∫—É
            btn_d = gr.Button('‚ñ∂ –†–æ–∑–ø–æ—á–∞—Ç–∏')
            with gr.Accordion('üîä –ü–æ—Ç–æ—á–Ω–∞ —á–∞—Å—Ç–∏–Ω–∞', open=False):
                autoplay_chk_d = gr.Checkbox(label='–ê–≤—Ç–æ–≤—ñ–¥—Ç–≤–æ—Ä–µ–Ω–Ω—è –ø—Ä–∏ –∑–º—ñ–Ω—ñ —á–∞—Å—Ç–∏–Ω–∏', value=False)
                output_audio_d = gr.Audio(label='üîä –ü–æ—Ç–æ—á–Ω–∞ —á–∞—Å—Ç–∏–Ω–∞', type='filepath', autoplay=False)
                part_slider_d = gr.Slider(label='–ß–∞—Å—Ç–∏–Ω–∞ —Ç–µ–∫—Å—Ç—É', minimum=1, maximum=1, step=1, value=1, interactive=False)
            with gr.Row():
                timer_text_d = gr.Textbox(label="‚è±Ô∏è –í—ñ–¥–ª—ñ–∫ —á–∞—Å—É (—Å–µ–∫)", value="0", interactive=False)
                start_time_text_d = gr.Textbox(label="–ü–æ—á–∞—Ç–æ–∫ –æ–∑–≤—É—á–µ–Ω–Ω—è", interactive=False)
                end_time_text_d = gr.Textbox(label="–ó–∞–∫—ñ–Ω—á–µ–Ω–Ω—è –æ–∑–≤—É—á–µ–Ω–Ω—è –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ—ó —á–∞—Å—Ç–∏–Ω–∏", interactive=False)
            with gr.Row():
                parts_progress_d = gr.Slider(label='–ß–∞—Å—Ç–∏–Ω –¥–ª—è –æ–∑–≤—É—á–µ–Ω–Ω—è', minimum=0, maximum=1, step=1, value=0, interactive=False)
            with gr.Row():
                est_end_time_text_d = gr.Textbox(label="–ü—Ä–æ–≥–Ω–æ–∑ –∑–∞–∫—ñ–Ω—á–µ–Ω–Ω—è", interactive=False)
                remaining_time_text_d = gr.Textbox(label="–ß–∞—Å –¥–æ –∑–∞–∫—ñ–Ω—á–µ–Ω–Ω—è", interactive=False)

            # –ü—ñ–¥–∫–∞–∑–∫–∞ –ø–æ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å—É —Ç–µ–≥—ñ–≤ —ñ —á–µ–∫–±–æ–∫—Å —ñ–≥–Ω–æ—Ä—É–≤–∞–Ω–Ω—è —à–≤–∏–¥–∫–æ—Å—Ç—ñ
            with gr.Accordion("–°–∏–Ω—Ç–∞–∫—Å–∏—Å —Ç–µ–≥—ñ–≤", open=False):
                gr.Markdown(
                """‚ùó **–°–∏–Ω—Ç–∞–∫—Å–∏—Å —Ç–µ–≥—ñ–≤:**  
* `#gN —Ç–µ–∫—Å—Ç` ‚Äî –æ–∑–≤—É—á–∏—Ç–∏ —Ç–µ–∫—Å—Ç –≥–æ–ª–æ—Å–æ–º ‚Ññ N (N=1..30).  
* `#gN_slow` / `#gN_fast` ‚Äî –≤—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ —à–≤–∏–¥–∫—ñ—Å—Ç—å –Ω–∞ 0.80 —á–∏ 1.20.  
* `#gN_slowNN` / `#gN_fastNN` ‚Äî –≤—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ —à–≤–∏–¥–∫—ñ—Å—Ç—å NN/100 (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥ 95 ‚Üí 0.95).  
* `#<sfx_id>` ‚Äî –≤—Å—Ç–∞–≤–∏—Ç–∏ SFX —ñ–∑ —Ñ–∞–π–ª—É `sfx.yaml`.  
–ü–æ—Ä–æ–∂–Ω—ñ —Ä—è–¥–∫–∏ —Ç–∞ –∫–æ–º–µ–Ω—Ç–∞—Ä—ñ (`# ...`) —ñ–≥–Ω–æ—Ä—É—é—Ç—å—Å—è.  
"""
                )
                ignore_speed_chk_d = gr.Checkbox(label='–Ü–≥–Ω–æ—Ä—É–≤–∞—Ç–∏ —à–≤–∏–¥–∫—ñ—Å—Ç—å', value=False)

            # –ü–û–í–ï–†–ù–ï–ù–Ü –ö–ù–û–ü–ö–ò –ó–ë–ï–†–ï–ñ–ï–ù–ù–Ø/–ó–ê–í–ê–ù–¢–ê–ñ–ï–ù–ù–Ø (–≤–∏–¥–∏–º—ñ –∑–≤–µ—Ä—Ö—É, –ø–æ–∑–∞ —Å–ø–æ–π–ª–µ—Ä–æ–º)
            with gr.Row():
                save_settings_download_btn_top = gr.DownloadButton("üíæ –ó–±–µ—Ä–µ–≥—Ç–∏ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –º–æ–≤—Ü—ñ–≤")
                save_settings_default_btn_top = gr.Button("üìÅ –ó–±–µ—Ä–µ–≥—Ç–∏ —É –ø–∞–ø–∫—É –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º")
                load_settings_btn_top = gr.UploadButton(
                    "üìÇ –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è (.txt)",
                    file_types=[".txt"],
                    file_count="single"
                )

            # –ü–æ—Ä—è–¥–æ–∫ inputs –¥–ª—è –∫–Ω–æ–ø–∫–∏ —Å—Ç–∞—Ä—Ç—É: —Ç–µ–∫—Å—Ç, —Ñ–∞–π–ª, 30 —à–≤–∏–¥–∫–æ—Å—Ç–µ–π, 30 –≥–æ–ª–æ—Å—ñ–≤, –æ–ø—Ü—ñ—è –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è, ignore_speed
            btn_inputs = [text_input_d, file_input_d] + speed_components + voice_components + [save_option_d, ignore_speed_chk_d]

            btn_outputs = [
                output_audio_d,
                part_slider_d,
                timer_text_d,
                start_time_text_d,
                end_time_text_d,
                est_end_time_text_d,
                remaining_time_text_d,
                parts_progress_d,
            ]


            # --- 1) –ï–ö–°–ü–û–†–¢ –£ –§–ê–ô–õ –î–õ–Ø –ó–ê–í–ê–ù–¢–ê–ñ–ï–ù–ù–Ø (—Å—Ç–∞–±—ñ–ª—å–Ω–æ, –±–µ–∑ –∫–µ—à—É —Ç–∞ ¬´—Å—Ç–∞—Ä–∏—Ö¬ª –∑–Ω–∞—á–µ–Ω—å) ---
            def export_speaker_settings_for_download(*flat_values):
                """
                –ì–µ–Ω–µ—Ä—É—î —Ç–µ–∫—Å—Ç –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó –∑ –ø–æ—Ç–æ—á–Ω–∏—Ö –∑–Ω–∞—á–µ–Ω—å UI —ñ –ø–æ–≤–µ—Ä—Ç–∞—î
                —à–ª—è—Ö –¥–æ –ù–û–í–û–ì–û —Ñ–∞–π–ª—É. –ö–æ–∂–µ–Ω –∫–ª—ñ–∫ ‚Üí –Ω–æ–≤–µ —ñ–º'—è (–±–µ–∑ –∫–µ—à—É).
                –í–ê–ñ–õ–ò–í–û: –ø–æ—Ä—è–¥–æ–∫ inputs –º–∞—î –±—É—Ç–∏ [voice_components ...] + [speed_components ...]
                """
                # 1) –ü–æ—Ç–æ—á–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è: —Å–ø–æ—á–∞—Ç–∫—É 30 dropdown (voices), –ø–æ—Ç—ñ–º 30 —Å–ª–∞–π–¥–µ—Ä—ñ–≤ (speeds)
                voices = list(flat_values[:30])
                speeds = list(flat_values[30:60])

                # 2) –ó—ñ–±—Ä–∞—Ç–∏ —Ç–µ–∫—Å—Ç –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó
                lines = []
                for i in range(30):
                    vname = str(voices[i]).strip()
                    try:
                        spd = float(speeds[i])
                    except Exception:
                        spd = 1.0
                    spd_str = f"{spd:.2f}".replace(".", ",")
                    lines.append(f"#g{i+1}:{vname} —à–≤–∏–¥–∫—ñ—Å—Ç—å:{spd_str};")
                text = "\n".join(lines) + "\n"

                # 3) –£–Ω—ñ–∫–∞–ª—å–Ω–µ —ñ–º'—è —Ñ–∞–π–ª—É —É –ø—ñ–¥—Ç–µ—Ü—ñ _exports (Windows-friendly)
                export_root = os.path.join(OUTPUT_DIR, "_exports")
                os.makedirs(export_root, exist_ok=True)
                fname = f"speakers_settings_{time.strftime('%Y%m%d_%H%M%S')}_{uuid.uuid4().hex[:6]}.txt"
                out_path = os.path.abspath(os.path.join(export_root, fname))

                # 4) –ó–∞–ø–∏—Å–∞—Ç–∏ —Ñ–∞–π–ª —ñ –ø–æ–≤–µ—Ä–Ω—É—Ç–∏ –π–æ–≥–æ —à–ª—è—Ö ‚Äî DownloadButton –æ–¥—Ä–∞–∑—É –≤—ñ–¥–¥–∞—Å—Ç—å —Ü–µ–π —Ñ–∞–π–ª
                with open(out_path, "w", encoding="utf-8") as fh:
                    fh.write(text)
                return out_path

            save_settings_download_btn.click(
                fn=export_speaker_settings_for_download,
                inputs=voice_components + speed_components,
                outputs=save_settings_download_btn,
            )
            # –¥—É–±–ª—é—î–º–æ –¥–ª—è –≤–µ—Ä—Ö–Ω—å–æ—ó –∫–Ω–æ–ø–∫–∏
            save_settings_download_btn_top.click(
                fn=export_speaker_settings_for_download,
                inputs=voice_components + speed_components,
                outputs=save_settings_download_btn_top,
            )

            # --- 2) –ó–ë–ï–†–ï–ñ–ï–ù–ù–Ø –£ –ü–ê–ü–ö–£ –ó–ê –ó–ê–ú–û–í–ß–£–í–ê–ù–ù–Ø–ú (OUTPUT_DIR) ---
            def save_speaker_settings_to_default(*flat_values):
                voices = list(flat_values[:30])
                speeds = list(flat_values[30:60])
                os.makedirs(OUTPUT_DIR, exist_ok=True)
                cfg_path = os.path.join(OUTPUT_DIR, "speakers_settings.txt")
                with open(cfg_path, "w", encoding="utf-8") as f:
                    for i in range(1, 31):
                        voice_name = str(voices[i-1]).strip()
                        try:
                            speed_val = float(speeds[i-1])
                        except Exception:
                            speed_val = 1.0
                        speed_str = f"{speed_val:.2f}".replace(".", ",")
                        f.write(f"#g{i}:{voice_name} —à–≤–∏–¥–∫—ñ—Å—Ç—å:{speed_str};\n")
                # –Ü–Ω—Ñ–æ—Ä–º—É–≤–∞—Ç–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
                gr.Info(f"‚úÖ –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –∑–±–µ—Ä–µ–∂–µ–Ω–æ: {cfg_path}")

            save_settings_default_btn.click(
                fn=save_speaker_settings_to_default,
                inputs=voice_components + speed_components,
                outputs=[],
            )
            save_settings_default_btn_top.click(
                fn=save_speaker_settings_to_default,
                inputs=voice_components + speed_components,
                outputs=[],
            )

            # --- 3) –ó–ê–í–ê–ù–¢–ê–ñ–ï–ù–ù–Ø –ù–ê–õ–ê–®–¢–£–í–ê–ù–¨ –ó –§–ê–ô–õ–£ (.txt) ---
            def load_speaker_settings_uploaded(files, *current_values):
                """
                –Ü–º–ø–æ—Ä—Ç—É—î –∑–Ω–∞—á–µ–Ω–Ω—è —É Dropdown/Slider –∑–≥—ñ–¥–Ω–æ —Ñ–∞–π–ª—É —É —Ñ–æ—Ä–º–∞—Ç—ñ:
                #gN:–ù–∞–∑–≤–∞ –≥–æ–ª–æ—Å—É —à–≤–∏–¥–∫—ñ—Å—Ç—å:0,88;
                –ó–∞—Å—Ç–æ—Å–æ–≤—É—î –∑–Ω–∞—á–µ–Ω–Ω—è –±–µ–∑ –ø–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Å—Ç–æ—Ä—ñ–Ω–∫–∏.
                """
                if not files:
                    raise gr.Error("–ù–µ –æ–±—Ä–∞–Ω–æ —Ñ–∞–π–ª –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω—å (.txt).")
                # UploadButton –º–æ–∂–µ –ø–æ–≤–µ—Ä—Ç–∞—Ç–∏ —Ä—è–¥–æ–∫-—à–ª—è—Ö, dict –∞–±–æ —Å–ø–∏—Å–æ–∫
                if isinstance(files, (list, tuple)):
                    src = files[0]
                else:
                    src = files  # –æ–¥–∏–Ω–æ—á–Ω–∏–π —à–ª—è—Ö/–æ–±'—î–∫—Ç
                file_path = str(src if isinstance(src, str) else (src.get("name") or src.get("path") if isinstance(src, dict) else getattr(src, "name", ""))) or None
                if not file_path: raise gr.Error("–ù–µ –≤–¥–∞–ª–æ—Å—è –≤–∏–∑–Ω–∞—á–∏—Ç–∏ —à–ª—è—Ö –¥–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ–≥–æ —Ñ–∞–π–ª—É.")

                pat = re.compile(
                    r'^#g([1-9]|[12]\d|30)\s*:\s*(.*?)\s*—à–≤–∏–¥–∫—ñ—Å—Ç—å\s*:\s*([0-9]+(?:[.,][0-9]+)?)\s*;\s*$',
                    re.IGNORECASE
                )
                # –ü–æ—Ç–æ—á–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è —è–∫ –¥–µ—Ñ–æ–ª—Ç–∏
                voices_out = list(current_values[:30])
                speeds_out = list(current_values[30:60])

                for line in open(file_path, "r", encoding="utf-8").read().splitlines():
                    m = pat.match(line.strip())
                    if not m:
                        continue
                    idx = int(m.group(1)) - 1
                    voice_name = m.group(2).strip()
                    speed_raw = m.group(3).replace(",", ".")
                    try:
                        speed_val = float(speed_raw)
                    except Exception:
                        speed_val = speeds_out[idx] if 0 <= idx < len(speeds_out) else 1.0
                    # –∫–ª—ñ–ø –¥–æ –º–µ–∂ –ø–æ–≤–∑—É–Ω–∫–∞
                    speed_val = max(0.7, min(1.3, speed_val))
                    if 0 <= idx < 30:
                        voices_out[idx] = voice_name
                        speeds_out[idx] = speed_val
                # –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ —É –ø–æ—Ä—è–¥–∫—É outputs: —Å–ø–æ—á–∞—Ç–∫—É –≤—Å—ñ dropdown, –ø–æ—Ç—ñ–º –≤—Å—ñ —Å–ª–∞–π–¥–µ—Ä–∏
                return voices_out + speeds_out

            # –û–±—Ä–æ–±–Ω–∏–∫ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è: –æ–Ω–æ–≤–ª—é—î–º–æ –ª–∏—à–µ –∑–Ω–∞—á–µ–Ω–Ω—è dropdown/slider –±–µ–∑ –ø–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Å—Ç–æ—Ä—ñ–Ω–∫–∏
            load_settings_btn.upload(
                fn=load_speaker_settings_uploaded,
                inputs=[load_settings_btn] + voice_components + speed_components,
                outputs=voice_components + speed_components,
            )
            load_settings_btn_top.upload(
                fn=load_speaker_settings_uploaded,
                inputs=[load_settings_btn_top] + voice_components + speed_components,
                outputs=voice_components + speed_components,
            )

            def _btn_d_handler(text_input, file_input, *flat_values):
                # flat_values: 30 speed sliders, 30 voice dropdowns, save_option, ignore_speed flag
                speeds = list(flat_values[:30])
                voices = list(flat_values[30:60])
                save_option = flat_values[60] if len(flat_values) > 60 else None
                ignore_speed = bool(flat_values[61]) if len(flat_values) > 61 else False
                yield from batch_synthesize_dialog_events(text_input, file_input, speeds, voices, save_option, ignore_speed)
            btn_d.click(
                fn=_btn_d_handler,
                inputs=btn_inputs,
                outputs=btn_outputs,
                show_progress=False
            )

            # === –Ü–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å —Å–ª–∞–π–¥–µ—Ä–∞ ¬´–ß–∞—Å—Ç–∏–Ω–∞ —Ç–µ–∫—Å—Ç—É¬ª –ø—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è ===
            def _on_part_slider_change(part_idx: int, autoplay: bool):
                try:
                    i = int(part_idx)
                except Exception:
                    gr.Warning("–ù–µ–∫–æ—Ä–µ–∫—Ç–Ω–∏–π –Ω–æ–º–µ—Ä —á–∞—Å—Ç–∏–Ω–∏")
                    return gr.update()
                wav_path = os.path.join(OUTPUT_DIR, f"part_{i:03}.wav")
                if not os.path.exists(wav_path):
                    gr.Error(f"–§–∞–π–ª –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ: {wav_path}")
                    return gr.update()
                # –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –∞—É–¥—ñ–æ. –Ø–∫—â–æ –ø—ñ–¥—Ç—Ä–∏–º—É—î—Ç—å—Å—è, –≤—Å—Ç–∞–Ω–æ–≤–∏–º–æ autoplay
                return gr.update(value=wav_path, autoplay=bool(autoplay))

            part_slider_d.change(
                fn=_on_part_slider_change,
                inputs=[part_slider_d, autoplay_chk_d],
                outputs=[output_audio_d],
            )

if __name__ == '__main__':
    demo.queue().launch()

# -----------------------------------------------------------------------------
# –ù–æ–≤–∏–π –≤–∞—Ä—ñ–∞–Ω—Ç –ø–∞–∫–µ—Ç–Ω–æ—ó –æ–∑–≤—É—á–∫–∏ Multi Dialog –∑ –ø—ñ–¥—Ç—Ä–∏–º–∫–æ—é –ø–æ–¥—ñ–π (voice/sfx),
# —à–≤–∏–¥–∫—ñ—Å–Ω–∏—Ö —Å—É—Ñ—ñ–∫—Å—ñ–≤ —Ç–∞ SFX. –§—É–Ω–∫—Ü—ñ—è —Å—Ç–≤–æ—Ä—é—î –æ–¥–∏–Ω –ª–æ–≥-—Ñ–∞–π–ª —É –ø–∞–ø—Ü—ñ
# OUTPUT_DIR —ñ –ø–æ–≤–µ—Ä—Ç–∞—î –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –¥–ª—è Gradio UI. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è —É
# _btn_d_handler –∑–∞–º—ñ—Å—Ç—å —Å—Ç–∞—Ä–æ—ó batch_synthesize_dialog.

def batch_synthesize_dialog_events(
    text_input: str | None,
    file_path: str | None,
    speeds_flat: list,
    voices_flat: list,
    save_option,
    ignore_speed: bool = False,
) -> Iterable:
    """
    –û–±—Ä–æ–±–ª—è—î —Å—Ü–µ–Ω–∞—Ä—ñ–π Multi Dialog, –ø—ñ–¥—Ç—Ä–∏–º—É—é—á–∏ SFX —Ç–∞ —Å—É—Ñ—ñ–∫—Å–∏ —à–≤–∏–¥–∫–æ—Å—Ç—ñ.
    –ù–∞ –∫–æ–∂–Ω—É –ø–æ–¥—ñ—é (voice –∞–±–æ sfx) —Å—Ç–≤–æ—Ä—é—î .wav —Ñ–∞–π–ª part_{k:03}.wav —ñ, –∑–∞ –±–∞–∂–∞–Ω–Ω—è,
    –∑–∞–ø–∏—Å—É—î —Ç–µ–∫—Å—Ç part_{k:03}.txt. –£—Å—ñ –ø–æ–¥—ñ—ó –ª–æ–≥—É—é—Ç—å—Å—è —É log_{timestamp}.txt.

    Parameters:
        text_input: –¢–µ–∫—Å—Ç —ñ–∑ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –ø–æ–ª—è (–º–æ–∂–µ –±—É—Ç–∏ None).
        file_path: –®–ª—è—Ö –¥–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Ñ–∞–π–ª—É (–º–æ–∂–µ –±—É—Ç–∏ None).
        speeds_flat: –ó–Ω–∞—á–µ–Ω–Ω—è —Å–ª–∞–π–¥–µ—Ä—ñ–≤ —à–≤–∏–¥–∫–æ—Å—Ç—ñ (—Å–ø–∏—Å–æ–∫ —ñ–∑ 30 –µ–ª–µ–º–µ–Ω—Ç—ñ–≤).
        voices_flat: –ó–Ω–∞—á–µ–Ω–Ω—è dropdown –¥–ª—è –≥–æ–ª–æ—Å—ñ–≤ (—Å–ø–∏—Å–æ–∫ —ñ–∑ 30 –µ–ª–µ–º–µ–Ω—Ç—ñ–≤).
        save_option: –û–ø—Ü—ñ—è –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è —Ç–µ–∫—Å—Ç–æ–≤–∏—Ö —á–∞—Å—Ç–∏–Ω.
        ignore_speed: –Ø–∫—â–æ True, —ñ–≥–Ω–æ—Ä—É–≤–∞—Ç–∏ —Å—É—Ñ—ñ–∫—Å–∏ —Ç–∞ –∑–Ω–∞—á–µ–Ω–Ω—è —Å–ª–∞–π–¥–µ—Ä—ñ–≤ —ñ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ DEFAULT_SPEED.
    Returns:
        –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä, —â–æ yield'–∏—Ç—å –∫–æ—Ä—Ç–µ–∂—ñ –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å—É Gradio.
    """
    # –°—Ç–≤–æ—Ä–∏—Ç–∏ –≤–∏—Ö—ñ–¥–Ω–∏–π –∫–∞—Ç–∞–ª–æ–≥ —ñ –∑–∞—Ñ—ñ–∫—Å—É–≤–∞—Ç–∏ —á–∞—Å —Å—Ç–∞—Ä—Ç—É
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    global_start = time.time()
    # –ü—Ä–æ—á–∏—Ç–∞—Ç–∏ —Ç–µ–∫—Å—Ç –∑ –ø–æ–ª—è –∞–±–æ —Ñ–∞–π–ª—É
    text = _read_text_source(text_input, file_path)
    # –ü—ñ–¥–≥–æ—Ç–æ–≤–∫–∞ —á–∞—Å—É —Å—Ç–∞—Ä—Ç—É –¥–ª—è –∫–æ–Ω—Å–æ–ª—ñ
    start_time_str = time.strftime('%H:%M:%S', time.localtime(global_start))
    print(f'Start: {start_time_str}')
    # –ü–∞—Ä—Å–∏–Ω–≥ —Å—Ü–µ–Ω–∞—Ä—ñ—é —É —Å–ø–∏—Å–æ–∫ –ø–æ–¥—ñ–π
    try:
        events = parse_script_events(text, voices_flat)
    except Exception as e:
        print(f'Error while parsing script: {e}')
        raise
    total_parts = max(1, len(events))
    times_per_part: List[float] = []
    warnings: List[str] = []
    base_sr: int | None = None
    # –°–ª–æ–≤–Ω–∏–∫ –≥–æ–ª–æ—Å—ñ–≤ –ø–æ g-–Ω–æ–º–µ—Ä—É
    voice_map = {i + 1: (voices_flat[i] if i < len(voices_flat) else None) for i in range(SPEAKER_MAX)}
    # –ü–æ—á–∞—Ç–∫–æ–≤–µ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å—É
    yield (
        None,
        gr.update(value=1, maximum=total_parts, interactive=False),
        "0 —Å–µ–∫",
        start_time_str,
        "",
        "–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫...",
        "",
        gr.update(value=0, maximum=total_parts, interactive=False),
    )
    # –û–±—Ä–æ–±–ª—è—î–º–æ –≤—Å—ñ –ø–æ–¥—ñ—ó –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ
    for idx, event in enumerate(events, start=1):
        part_start = time.time()
        # –í–∏–∑–Ω–∞—á–∏—Ç–∏ —Ç–∏–ø –ø–æ–¥—ñ—ó
        if event.get('type') == 'voice':
            g_num = event.get('g')
            suffix = event.get('suffix', '')
            text_body = event.get('text', '')
            voice_name = voice_map.get(g_num, None)
            # –û–±—á–∏—Å–ª–∏—Ç–∏ –µ—Ñ–µ–∫—Ç–∏–≤–Ω—É —à–≤–∏–¥–∫—ñ—Å—Ç—å
            speed_eff = _compute_speed_effective(g_num, suffix, speeds_flat, ignore_speed)
            # –ó–±–µ—Ä–µ–≥—Ç–∏ –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è –ø—Ä–æ –≤–∏—Ö—ñ–¥ –∑–∞ –º–µ–∂—ñ —Å–ª–∞–π–¥–µ—Ä–∞
            if not ignore_speed and (speed_eff < 0.7 or speed_eff > 1.3):
                warnings.append(f'–í–∏—Ö—ñ–¥ –∑–∞ –º–µ–∂—ñ —Å–ª–∞–π–¥–µ—Ä–∞ —à–≤–∏–¥–∫–æ—Å—Ç—ñ –¥–ª—è #g{g_num}: {speed_eff:.2f}')
            # –ü–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è —è–∫—â–æ –≥–æ–ª–æ—Å –Ω–µ –æ–±—Ä–∞–Ω–æ
            if not voice_name:
                warnings.append(f'–ù–µ –≤–∫–∞–∑–∞–Ω–æ –≥–æ–ª–æ—Å –¥–ª—è #g{g_num}, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏–π –≥–æ–ª–æ—Å.')
            call_func = _synthesize_chunk
            call_args = (text_body, voice_name, speed_eff)
            extra_info = {
                "type": "voice",
                "g": g_num,
                "voice_name": voice_name,
                "speed_eff": speed_eff,
                "text_len": len(text_body),
                "text_body": text_body,
            }
        elif event.get('type') == 'sfx':
            sfx_id = event.get('id')
            # –í–∏–∑–Ω–∞—á–∏—Ç–∏ —á–∞—Å—Ç–æ—Ç—É –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü—ñ—ó: –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ –±–∞–∑–æ–≤—É, —è–∫—â–æ –≤–æ–Ω–∞ –≤–∂–µ –≤—ñ–¥–æ–º–∞, —ñ–Ω–∞–∫—à–µ ‚Äì 24000 –∞–±–æ –∑–Ω–∞—á–µ–Ω–Ω—è –∑ –∫–æ–Ω—Ñ—ñ–≥—É
            target_sr = base_sr if base_sr else int(SFX_CONFIG.get('default_sr', 24000))
            call_func = _load_and_process_sfx
            call_args = (sfx_id, target_sr)
            cfg = SFX_CONFIG.get('sounds', {}).get(sfx_id, {})
            extra_info = {
                "type": "sfx",
                "sfx_id": sfx_id,
                "file": cfg.get('file'),
                "gain_db": cfg.get('gain_db', 0.0),
            }
        else:
            warnings.append(f"–ù–µ–≤—ñ–¥–æ–º–∏–π —Ç–∏–ø –ø–æ–¥—ñ—ó: {event}")
            continue
        # –í–∏–∫–æ–Ω–∞—Ç–∏ —Å–∏–Ω—Ç–µ–∑ –∞–±–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —É –æ–∫—Ä–µ–º–æ–º—É –ø–æ—Ç–æ—Ü—ñ, —â–æ–± –º–æ–∂–Ω–∞ –±—É–ª–æ –æ–Ω–æ–≤–ª—é–≤–∞—Ç–∏ –ø—Ä–æ–≥—Ä–µ—Å
        with ThreadPoolExecutor(max_workers=1) as executor:
            future = executor.submit(call_func, *call_args)
            while not future.done():
                now = time.time()
                elapsed = int(now - global_start)
                elapsed_str = f"{elapsed} —Å–µ–∫ --- {format_hms(elapsed)}"
                est_finish_str = '–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫...'
                rem_text = '–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫...'
                if times_per_part:
                    avg_time = sum(times_per_part) / len(times_per_part)
                    est_total_time = avg_time * total_parts
                    est_finish_str = time.strftime('%H:%M:%S', time.localtime(global_start + est_total_time))
                    rem_secs = int(global_start + est_total_time - now)
                    rem_min, rem_sec = divmod(max(rem_secs, 0), 60)
                    rem_text = f"–¥–æ –∑–∞–∫—ñ–Ω—á–µ–Ω–Ω—è –∑–∞–ª–∏—à–∏–ª–æ—Å—è {rem_min} —Ö–≤ {rem_sec} —Å–µ–∫"
                yield (
                    None,
                    gr.update(value=idx, maximum=total_parts, interactive=False),
                    elapsed_str,
                    start_time_str,
                    None,
                    est_finish_str,
                    rem_text,
                    gr.update(value=max(idx - 1, 0), maximum=total_parts, interactive=False),
                )
                time.sleep(PROGRESS_POLL_INTERVAL)
            try:
                sr, audio_np = future.result()
            except Exception as e:
                # –í–∏–≤–µ—Å—Ç–∏ –ø–æ–º–∏–ª–∫—É —É –∫–æ–Ω—Å–æ–ª—å –±–µ–∑ –∑–∞–ø–∏—Å—É —É —Ñ–∞–π–ª
                print(f'Error processing part {idx}: {e}')
                raise
        # –î–ª—è –ø–µ—Ä—à–æ–≥–æ voice –∑–∞–ø–∞–º'—è—Ç–∞—Ç–∏ —á–∞—Å—Ç–æ—Ç—É –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü—ñ—ó
        if extra_info["type"] == "voice" and base_sr is None:
            base_sr = sr
        # –ó–∞–ø–∏—Å–∞—Ç–∏ –∞—É–¥—ñ–æ —Ñ–∞–π–ª
        audio_filename = os.path.join(OUTPUT_DIR, f"part_{idx:03}.wav")
        sf.write(audio_filename, audio_np, sr)
        # –ó–∞ –ø–æ—Ç—Ä–µ–±–∏ ‚Äì –∑–∞–ø–∏—Å–∞—Ç–∏ —Ç–µ–∫—Å—Ç–æ–≤–∏–π —Ñ–∞–π–ª
        if save_option == '–ó–±–µ—Ä–µ–≥—Ç–∏ –≤—Å—ñ —á–∞—Å—Ç–∏–Ω–∏ –æ–∑–≤—É—á–µ–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç—É' and extra_info["type"] == "voice":
            txt_filename = os.path.join(OUTPUT_DIR, f"part_{idx:03}.txt")
            with open(txt_filename, 'w', encoding='utf-8') as txt_file:
                txt_file.write(extra_info["text_body"])
        # –í–∏–≤–µ—Å—Ç–∏ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é —É –∫–æ–Ω—Å–æ–ª—å
        if extra_info["type"] == "voice":
            print(f'Part {idx}: type=voice, g={extra_info["g"]}, voice={extra_info["voice_name"]}, speed={extra_info["speed_eff"]:.2f}, text_len={extra_info["text_len"]}, path={audio_filename}')
        else:
            # –î–ª—è SFX: –¥—Ä—É–∫—É—î–º–æ —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä —ñ —à–ª—è—Ö –¥–æ —Ñ–∞–π–ª—É
            print(f'#{extra_info["sfx_id"]} --- —Ñ–∞–π–ª "{extra_info["file"]}" -- {os.path.basename(audio_filename)}')
        # –û–Ω–æ–≤–∏—Ç–∏ —Ç–∞–π–º—ñ–Ω–≥–∏ —Ç–∞ UI
        part_end = time.time()
        times_per_part.append(part_end - part_start)
        end_time_str = time.strftime('%H:%M:%S', time.localtime(part_end))
        elapsed_seconds = int(part_end - global_start)
        elapsed_total = f"{elapsed_seconds} —Å–µ–∫ --- {format_hms(elapsed_seconds)}"
        yield (
            audio_filename,
            gr.update(value=idx, maximum=total_parts, interactive=False),
            elapsed_total,
            start_time_str,
            end_time_str,
            None,
            "",
            gr.update(value=idx, maximum=total_parts, interactive=False),
        )
    # –ü—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è ‚Äì –∑–∞–ø–∏—Å–∞—Ç–∏ –ø—ñ–¥—Å—É–º–æ–∫
    total_elapsed_secs = int(time.time() - global_start)
    total_formatted = format_hms(total_elapsed_secs)
    finish_time_str = time.strftime('%H:%M:%S', time.localtime(time.time()))
    print(f'Finished: {finish_time_str}, duration: {total_formatted}, parts: {len(events)}')
    if warnings:
        print('Warnings:')
        for w in warnings:
            print(f'  - {w}')
    print(f"\033[92m–ó–∞—Ç—Ä–∞—á–µ–Ω–æ —á–∞—Å—É: {total_formatted}\033[0m")
    yield (
        None,
        gr.update(value=total_parts, maximum=total_parts, interactive=True),
        f"–ó–∞–≤–µ—Ä—à–µ–Ω–æ –∑–∞ {total_elapsed_secs} —Å–µ–∫",
        start_time_str,
        finish_time_str,
        None,
        "",
        gr.update(value=total_parts, maximum=total_parts, interactive=False),
    )